/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface ISeaportInterface extends ethers.utils.Interface {
  functions: {
    "fulfillAdvancedOrder(((address,address,tuple[],tuple[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes),tuple[],bytes32,address)": FunctionFragment;
    "fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,tuple[],bytes))": FunctionFragment;
    "fulfillOrder(((address,address,tuple[],tuple[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes))": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "fulfillAdvancedOrder",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      BytesLike,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillBasicOrder",
    values: [
      {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillOrder",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "fulfillAdvancedOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillBasicOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillOrder",
    data: BytesLike
  ): Result;

  events: {};
}

export class ISeaport extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: ISeaportInterface;

  functions: {
    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  fulfillAdvancedOrder(
    advancedOrder: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      numerator: BigNumberish;
      denominator: BigNumberish;
      signature: BytesLike;
      extraData: BytesLike;
    },
    criteriaResolvers: {
      orderIndex: BigNumberish;
      side: BigNumberish;
      index: BigNumberish;
      identifier: BigNumberish;
      criteriaProof: BytesLike[];
    }[],
    fulfillerConduitKey: BytesLike,
    recipient: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillBasicOrder(
    parameters: {
      considerationToken: string;
      considerationIdentifier: BigNumberish;
      considerationAmount: BigNumberish;
      offerer: string;
      zone: string;
      offerToken: string;
      offerIdentifier: BigNumberish;
      offerAmount: BigNumberish;
      basicOrderType: BigNumberish;
      startTime: BigNumberish;
      endTime: BigNumberish;
      zoneHash: BytesLike;
      salt: BigNumberish;
      offererConduitKey: BytesLike;
      fulfillerConduitKey: BytesLike;
      totalOriginalAdditionalRecipients: BigNumberish;
      additionalRecipients: { amount: BigNumberish; recipient: string }[];
      signature: BytesLike;
    },
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillOrder(
    order: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      signature: BytesLike;
    },
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {};

  estimateGas: {
    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
